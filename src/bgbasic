#!/usr/bin/env python3

import sys
import argparse

from lexer import Lexer
from parser import Parser
from interpreter import Interpreter, RuntimeError as InterpreterError
from token import TK_LINEBREAK, TK_DONE


def run_file(path):
    try:
        code = open(path, 'r').read()
    except IOError as e:
        print(f"Could not open {path}: {e}", file=sys.stderr)
        sys.exit(1)

    lexer = Lexer(path, code)
    tokens = lexer.tokenize()
    parser = Parser(tokens)
    ast = parser.parse()
    interpreter = Interpreter()

    try:
        interpreter.interpret(ast)
    except InterpreterError as e:
        print(f"Runtime error: {e}", file=sys.stderr)
        sys.exit(1)

def has_unclosed_block(buffer: str) -> bool:
    # look for lines that start a block:\
    opens = (
        buffer.count("if ")
      + buffer.count("orferb ")
      + buffer.count("atchmerb ")
    )
    closes = buffer.count("ndeerb")

    # also count unmatched '[' vs ']'
    unclosed_arrays = buffer.count('[') - buffer.count(']')

    # keep buffering if any Ferb‐block is unclosed OR any array literal is unclosed
    return (closes < opens) or (unclosed_arrays > 0)

def is_incomplete_input_error(msg: str, buffer: str) -> bool:
    return any(
        phrase in msg for phrase in [
            "Unexpected end of input",
            "Expected 'ndeerb'",
            "Expected newline", 
            "Expected ']'",
            "got EOF",
            "unterminated block",
            "Expected at least one 'asecerb'",
        ]
    ) or buffer.strip().startswith(("atchmerb", "if", "orferb")) or has_unclosed_block(buffer)


def repl():
    print("FERB Latin REPL v0.1  (Ctrl-D or :exit to quit)\n")
    interpreter = Interpreter()
    buffer = ""
    last_good_buffer = ""

    while True:
        try:
            prompt = "erb erb >>> " if not buffer else "... "
            line = input(prompt).rstrip()
        except EOFError:
            print("\nExiting.")
            break

        if line.strip() == ":exit":
            break
        if line.strip() == ":clear":
            buffer = ""
            continue
        elif line.strip() == ":tokens":
            if not last_good_buffer.strip():
                print("(nothing to tokenize)")
            else:
                lexer = Lexer("<repl>", last_good_buffer)
                tokens = lexer.tokenize()
                print(tokens)
            continue

        elif line.strip() == ":ast":
            if not last_good_buffer.strip():
                print("(no previous input)")
            else:
                lexer = Lexer("<repl>", last_good_buffer)
                tokens = lexer.tokenize()
                parser = Parser(tokens)
                ast = parser.parse()
                print(ast)
            continue

        if not line and not buffer:
            continue

        buffer += line + "\n"

        try:
            lexer = Lexer("<repl>", buffer)
            tokens = lexer.tokenize()

            if all(t.type in {TK_LINEBREAK, TK_DONE} for t in tokens):
                continue

            parser = Parser(tokens)
            ast = parser.parse()

            interpreter.interpret(ast)
            last_good_buffer = buffer  # <── save this
            buffer = ""

        except InterpreterError as e:
            print(f"Runtime error: {e}")
            buffer = ""
        except Exception as e:
            msg = str(e)
            if is_incomplete_input_error(msg, buffer):
                continue  # keep buffering
            print(f"Parse error: {e}")
            buffer = ""
        


def main():
    p = argparse.ArgumentParser(prog="bigbasic",
        description="BigBasic: run .erb scripts or drop into the REPL")
    p.add_argument("file", nargs="?", help="Path to a .erb source file")
    args = p.parse_args()

    if args.file:
        if not args.file.endswith(".erb"):
            print(f"Warning: expected a .erb file, but got '{args.file}'", file=sys.stderr)
        run_file(args.file)
    else:
        repl()

if __name__ == "__main__":
    main()
